#!/usr/bin/env bash

set -eEo pipefail

# set a restrictive default umask
umask 077

## Helper functions

clean_path() (
    printf '%s' "$1" | sed "s/\\/\\{2,\\}/\\//g"
)

join_path() (
    clean_path "$(printf '/%s' "$@")"
)

get_extension() (
    printf '%s' "${1##*.}"
)

highlight_str() (
    case "$1" in
        yellow) highlight_color_code=33 ;;
        purple) highlight_color_code=35 ;;
        green) highlight_color_code=32 ;;
        cyan) highlight_color_code=36 ;;
        blue) highlight_color_code=34 ;;
        red) highlight_color_code=31 ;;
        *) highlight_color_code=37 ;;
    esac

    printf '\033[4;%dm%s\033[0m' "$highlight_color_code" "$2"
)

success_message() (
    _action="${1:?}"
    _src="${2:?}"
    _dest="${3:?}"

    printf '%s from %s to %s\n' "$_action" "$(highlight_str green "~${_src#"${HOME}"}")" "$(highlight_str green "~${_dest#"${HOME}"}")"
)

failure_message() (
    _action="${1:?}"
    _src="${2:?}"
    _dest="${3:?}"

    printf '%s from %s to %s\n' "$_action" "$(highlight_str red "~${_src#"${HOME}"}")" "$(highlight_str red "~${_dest#"${HOME}"}")"
)

# Adds a trailing slash to a path if it's a directory
ensure_trailing_slash() (
    df_path="$1"
    if [ -d "$df_path" ]; then
        while [ "${df_path%/}" != "$df_path" ]; do
            df_path="${df_path%/}"
        done
        printf '%s' "${df_path}/"
    else
        printf '%s' "$df_path"
    fi
)

# Removes all trailing slashes
strip_trailing_slashes() (
    # ensure_trailing_slash makes sure there is one and only one trailing slash
    df_path="$(ensure_trailing_slash "$1")"
    # Print out the result while removing the trailing slash (if it exists)
    printf '%s' "${df_path%/}"
)

## Variables

script_name="$(basename "$0")"

# Set base dir as the directory of this script
dotfiles_base_dir="$(cd "$(dirname "$0")" && pwd -P)"
scripts_dir="$(join_path "${dotfiles_base_dir}" "scripts")"
dotfiles_dir="$(join_path "${dotfiles_base_dir}" "files")"
dotfiles_env_dir="$(join_path "${dotfiles_base_dir}" "files-env")"
backups_base="${dotfiles_base_dir}/backups/backup-$(date "+%Y-%m-%d-%H%M%S")"

# Set option defaults
no_copies=${DOTFILES_NO_COPIES:-0}
no_links=${DOTFILES_NO_LINKS:-0}
no_backups=${DOTFILES_NO_BACKUPS:-0}
do_script=

## Handle Dotfiles

if [ -z "$script_name" ]; then
    printf "%s\\n" "Could not determine script name. Exiting..."
    exit 1
fi

if [ -z "${dotfiles_base_dir#/}" ]; then
    printf "%s\\n" "Dotfiles base dir was empty or /. Exiting..."
    exit 1
fi

backup_original() (
    _src="${1:?"No source path given"}"

    backup_dest="$(join_path "$backups_base" "${_src#"${HOME}"}")"
    backup_parent="$(dirname "$backup_dest")"

    if [ "$no_backups" = 0 ] && [ -e "$_src" ]; then
        if [ ! -d "$backup_parent" ]; then
            mkdir -p "$backup_parent"
        fi

        mv "$_src" "$backup_dest"
    elif [ "$no_backups" = 0 ]; then
        # Make sure the file/folder we're trying to replace is not contained in a broken symlink
        while [ "$_src" != "$HOME" ] && [ "${_src#"${HOME}"}" != "$_src" ]; do
            if [ -L "$_src" ] && [ ! -e "$_src" ]; then
                if [ ! -d "$backup_parent" ]; then
                    mkdir -p "$backup_parent"
                fi
                # Might as well backup the broken link too, it will take up almost no space.
                mv "$_src" "$backup_dest"
            else
                # strip the last segment of the file path for the next iteration
                _src="${_src%/*}"
            fi
        done
    # Otherwise we need to remove the file/dir/link
    else
        # Strip any trailing slashes so we can properly detect a symlink to a directory
        _src="$(strip_trailing_slashes "$_src")"

        if [ -L "$_src" ] || [ -f "$_src" ]; then
            rm "$_src"
        elif [ -d "$_src" ]; then
            rm -rf "$_src"
        fi
    fi
)

mk_dest_dir() (
    _path="${1:?"No path given"}"

    if [ "$_path" = "$HOME" ] || [ -d "$_path" ]; then
        return
    fi

    # Attempt to create the directory in case it doesn't exist
    mkdir -p "$_path"

    printf "Created directory %s\\n" "$(highlight_str blue "~${_path#"${HOME}"}")"
)

copy_path() (
    _src="${1:?"No source path given"}"
    _dest="${2:?"No destination path given"}"

    if [ "$no_copies" = 1 ]; then
        return
    fi

    _src="$(ensure_trailing_slash "$_src")"

    backup_original "$_dest"
    mk_dest_dir "$(dirname "$_dest")"

    cp -afR "$_src" "$_dest" && success_message 'Copied' "$_src" "$_dest"
)

link_path() (
    _src="${1:?"No source path given"}"
    _dest="${2:?"No destination path given"}"

    if [ "$no_links" = 1 ]; then
        return
    fi

    _src="$(strip_trailing_slashes "$_src")"

    backup_original "$_dest"
    mk_dest_dir "$(dirname "$_dest")"

    ln -sf "$_src" "$_dest" && success_message 'Softlinked' "$_src" "$_dest"
)

hardlink_file() (
    _src="${1:?"No source path given"}"
    _dest="${2:?"No destination path given"}"

    if [ "$no_links" = 1 ]; then
        return
    fi

    if [ -d "$_src" ]; then
        failure_message 'Unable to hardlink directory' "$_src" "$_dest"
    fi

    _src="$(strip_trailing_slashes "$_src")"

    backup_original "$_dest"
    mk_dest_dir "$(dirname "$_dest")"

    ln -f "$_src" "$_dest" && success_message 'Hardlinked' "$_src" "$_dest"
)

process_dotfiles() (
    _dir="${1:-"$dotfiles_dir"}"
    _src_base="${2}"
    _dest_base="${3}"

    if [ -n "$_src_base" ] && [ -z "$_dest_base" ]; then
        printf "%s\n" "$(highlight_str red "\"\$_src_base\" cannot have a value while \"\$_dest_base\" is empty. Exiting...")"
        exit 1
    elif [ -z "$_src_base" ] && [ -n "$_dest_base" ]; then
        printf "%s\n" "$(highlight_str red "\"\$_dest_base\" cannot have a value while \"\$_src_base\" is empty. Exiting...")"
        exit 1
    fi

    for _src in "$_dir"/* "$_dir"/.[!.]* "$_dir"/..?*; do
        if [ ! -e "$_src" ] && [ ! -L "$_src" ]; then
            continue
        fi

        _type="$(get_extension "$_src")"

        if [ -z "$_src_base" ] && [ -z "$_dest_base" ]; then
            _dest="$(join_path "$HOME" "${_src#"${dotfiles_dir}"}")"
        else
            _dest="$(join_path "$_dest_base" "${_src#"${_src_base}"}")"
        fi

        # Remove .link, .hardlink, and .copy from the destination name
        _dest="${_dest%.link}"
        _dest="${_dest%.hardlink}"
        _dest="${_dest%.copy}"

        case "$_type" in
            copy)
                copy_path "$_src" "$_dest"
                ;;
            link)
                link_path "$_src" "$_dest"
                ;;
            hardlink)
                hardlink_file "$_src" "$_dest"
                ;;
            *)
                if [ -d "$_src" ]; then
                    process_dotfiles "$_src" "$_src_base" "$_dest_base"
                fi
                ;;
        esac
    done
)

process_dotfiles_from_env_path() (
    _dir="${dotfiles_env_dir}"

    for _src in "$_dir"/* "$_dir"/.[!.]* "$_dir"/..?*; do
        if [ ! -d "$_src" ]; then
            continue
        fi

        env_var_name="${_src##*/}"

        if [ -z "$env_var_name" ]; then
            printf "%s\n" "$(highlight_str red "Environment variable name not given! exiting")"
            exit 1
        fi

        env_var_value="${!env_var_name}"

        if [ -z "$env_var_value" ]; then
            # Try to set some default fallbacks
            case "$env_var_name" in
                XDG_CONFIG_HOME)
                    env_var_value="${HOME}/.config"
                    ;;
                XDG_DATA_HOME)
                    env_var_value="${HOME}/.local/share"
                    ;;
                XDG_STATE_HOME)
                    env_var_value="${HOME}/.local/state"
                    ;;
                *)
                    printf "%s\n" "$(highlight_str yellow "Environment variable \"${env_var_name}\" not set, skipping directory...")"
                    continue
                    ;;
            esac
        fi

        printf "%s\n" "$(highlight_str cyan "Resolved \"\$${env_var_name}\" to \"${env_var_value}\"")"

        process_dotfiles "$_src" "$_src" "$env_var_value"
    done
)

install() (
    process_dotfiles && process_dotfiles_from_env_path
)

## Handle Settings

run_script() (
    script_type="$1"
    script_name="$2"

    if [ -z "$script_name" ]; then
        echo "Error: no ${script_type} script name specified"
        print_help >&2
        exit 1
    fi

    script_file_path="$(join_path "$scripts_dir" "$script_type" "$script_name")"

    if [ ! -r "$script_file_path" ]; then
        echo "Error: ${script_type} script \"${script_name}\" does not exist or is not readable! Exiting..."
        exit 1
    fi

    if [ ! -x "$script_file_path" ]; then
        echo "Error: ${script_type} script \"${script_name}\" is not executable! Exiting..."
        exit 1
    fi

    "$script_file_path"
)

## Main

print_help() {
    printf 'Usage: ~%s/%s [-h|--help] [--no-copies] [--no-links] [--no-backups]\n' "${dotfiles_base_dir#"${HOME}"}" "$script_name"
}

# Handle options

while :; do
    # Break the loop if we have no arguments, otherwise we'll hit an error case
    if [ -z "$1" ]; then
        break
    fi

    case "$1" in
        -h|--help)
            print_help
            exit
            ;;
        --no-copies)
            no_copies=1
            shift
            ;;
        --no-links)
            no_links=1
            shift
            ;;
        --no-backups)
            no_backups=1
            shift
            ;;
        install|upgrade|settings)
            do_script="$1"
            shift
            break
            ;;
        --)
            shift
            break
            ;;
        -?*)
            printf 'Unknown option: %s\n' "$1" >&2
            print_help >&2
            exit 1
            ;;
        ?*)
            printf 'Unknown command: %s\n' "$1" >&2
            print_help >&2
            exit 1
            ;;
        *)
            print_help >&2
            exit 1
            ;;
    esac
done

if [ -n "$do_script" ]; then
    run_script "$do_script" "$1"
    exit $?
fi

install
